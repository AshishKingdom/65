# Copyright 2020 Luke Ceddia
# SPDX-License-Identifier: Apache-2.0
# tokens.list - Description of parser tokens

generic unknown   ; nosym
generic eof       ; nosym
# End Of Input - used to signify the end of a user's input in interactive
# mode (can't use newline because we're always looking one token ahead).
generic eoi       ; nosym
generic newline   ; direct nosym
generic comma     ; direct nosym
generic semicolon ; direct nosym
generic rem
generic linenum   ; nosym

# Literals have a hard-coded precedence of 1, which needs to be lower than any other
# The precedence of NOT may surprise you; NOT 2 + 3 is NOT (2 + 3).
# Note -3^2 = -(3^2)
#       name   precedence  assoc.   return    args
infix   imp             2   left    integer   integer,integer
infix   imp             2   left    long      long,long
infix   imp             2   left    integer64 integer64,integer64
infix   eqv             3   left    integer   integer,integer
infix   eqv             3   left    long      long,long
infix   eqv             3   left    integer64 integer64,integer64
infix   xor             4   left    integer   integer,integer
infix   xor             4   left    long      long,long
infix   xor             4   left    integer64 integer64,integer64
infix   or              5   left    integer   integer,integer
infix   or              5   left    long      long,long
infix   or              5   left    integer64 integer64,integer64
infix   and             6   left    integer   integer,integer
infix   and             6   left    long      long,long
infix   and             6   left    integer64 integer64,integer64
prefix  not             7           integer   integer 
prefix  not             7           long      long
prefix  not             7           integer64 integer64
infix   =(equals)       8   left    integer   string,string       ; direct
infix   =(equals)       8   left    integer   integer,integer     ; direct
infix   =(equals)       8   left    integer   long,long           ; direct
infix   =(equals)       8   left    integer   integer64,integer64 ; direct
infix   =(equals)       8   left    integer   single,single       ; direct
infix   =(equals)       8   left    integer   double,double       ; direct
infix   =(equals)       8   left    integer   quad,quad           ; direct
infix   <>(cmp_neq)     8   left    integer   string,string       ; direct
infix   <>(cmp_neq)     8   left    integer   integer,integer     ; direct
infix   <>(cmp_neq)     8   left    integer   long,long           ; direct
infix   <>(cmp_neq)     8   left    integer   integer64,integer64 ; direct
infix   <>(cmp_neq)     8   left    integer   single,single       ; direct
infix   <>(cmp_neq)     8   left    integer   double,double       ; direct
infix   <>(cmp_neq)     8   left    integer   quad,quad           ; direct
infix   <(cmp_lt)       8   left    integer   string,string       ; direct
infix   <(cmp_lt)       8   left    integer   integer,integer     ; direct
infix   <(cmp_lt)       8   left    integer   long,long           ; direct
infix   <(cmp_lt)       8   left    integer   integer64,integer64 ; direct
infix   <(cmp_lt)       8   left    integer   single,single       ; direct
infix   <(cmp_lt)       8   left    integer   double,double       ; direct
infix   <(cmp_lt)       8   left    integer   quad,quad           ; direct
infix   >(cmp_gt)       8   left    integer   string,string       ; direct
infix   >(cmp_gt)       8   left    integer   integer,integer     ; direct
infix   >(cmp_gt)       8   left    integer   long,long           ; direct
infix   >(cmp_gt)       8   left    integer   integer64,integer64 ; direct
infix   >(cmp_gt)       8   left    integer   single,single       ; direct
infix   >(cmp_gt)       8   left    integer   double,double       ; direct
infix   >(cmp_gt)       8   left    integer   quad,quad           ; direct
infix   <=(cmp_lteq)    8   left    integer   string,string       ; direct
infix   <=(cmp_lteq)    8   left    integer   integer,integer     ; direct
infix   <=(cmp_lteq)    8   left    integer   long,long           ; direct
infix   <=(cmp_lteq)    8   left    integer   integer64,integer64 ; direct
infix   <=(cmp_lteq)    8   left    integer   single,single       ; direct
infix   <=(cmp_lteq)    8   left    integer   double,double       ; direct
infix   <=(cmp_lteq)    8   left    integer   quad,quad           ; direct
infix   >=(cmp_gteq)    8   left    integer   string,string       ; direct
infix   >=(cmp_gteq)    8   left    integer   integer,integer     ; direct
infix   >=(cmp_gteq)    8   left    integer   long,long           ; direct
infix   >=(cmp_gteq)    8   left    integer   integer64,integer64 ; direct
infix   >=(cmp_gteq)    8   left    integer   single,single       ; direct
infix   >=(cmp_gteq)    8   left    integer   double,double       ; direct
infix   >=(cmp_gteq)    8   left    integer   quad,quad           ; direct
infix   +(plus)         9   left    string    string,string       ; direct
infix   +(plus)         9   left    integer   integer,integer     ; direct
infix   +(plus)         9   left    long      long,long           ; direct
infix   +(plus)         9   left    integer64 integer64,integer64 ; direct
infix   +(plus)         9   left    single    single,single       ; direct
infix   +(plus)         9   left    double    double,double       ; direct
infix   +(plus)         9   left    quad      quad,quad           ; direct
infix   -(dash)         9   left    integer   integer,integer     ; direct
infix   -(dash)         9   left    long      long,long           ; direct
infix   -(dash)         9   left    integer64 integer64,integer64 ; direct
infix   -(dash)         9   left    single    single,single       ; direct
infix   -(dash)         9   left    double    double,double       ; direct
infix   -(dash)         9   left    quad      quad,quad           ; direct
infix   mod             10  left    integer   integer,integer
infix   mod             10  left    long      long,long
infix   mod             10  left    integer64 integer64,integer64
infix   \(backslash)    11  left    integer   integer,integer     ; direct
infix   \(backslash)    11  left    long      long,long           ; direct
infix   \(backslash)    11  left    integer64 integer64,integer64 ; direct
infix   *(star)         12  left    long      integer,integer     ; direct
infix   *(star)         12  left    integer64 long,long           ; direct
infix   *(star)         12  left    quad      integer64,integer64 ; direct
infix   *(star)         12  left    single    single,single       ; direct
infix   *(star)         12  left    double    double,double       ; direct
infix   *(star)         12  left    quad      quad,quad           ; direct
infix   /(slash)        12  left    single    single,single       ; direct
infix   /(slash)        12  left    double    double,double       ; direct
infix   /(slash)        12  left    quad      quad,quad           ; direct
prefix  negative        13          integer   integer             ; nosym
prefix  negative        13          long      long                ; nosym
prefix  negative        13          integer64 integer64           ; nosym
prefix  negative        13          single    single              ; nosym
prefix  negative        13          double    double              ; nosym
prefix  negative        13          quad      quad                ; nosym
infix   ^(power)        14  left    single    single,single       ; direct
infix   ^(power)        14  left    double    double,double       ; direct
infix   ^(power)        14  left    quad      quad,quad           ; direct

# Parentheses don't have any real meaning, they only direct the parsing
generic oparen ; direct nosym
generic cparen ; direct nosym

# Numbers
# numint: 1234, numdec: 12.34, numexp: 12.3E4, numbase: &H1234
literal numint ; direct
literal numdec ; direct
literal numexp ; direct
literal numbase ; direct
# A string
literal stringlit ; direct

# Type symbols and names
generic integer_sfx     ; direct nosym
generic integer
generic long_sfx        ; direct nosym
generic long
generic integer64_sfx   ; direct nosym
generic integer64
generic offset_sfx      ; direct nosym
generic offset

generic single_sfx      ; direct nosym
generic single
generic double_sfx      ; direct nosym
generic double
generic quad_sfx        ; direct nosym
generic quad
generic string_sfx      ; direct nosym
generic string


# Basic language constructs
generic dim
generic as
generic const
generic goto

generic if
generic then
generic else
generic elseif
# end is special because it's both a command on its own and part of END IF.
# It gets special treatment in the statement parser.
generic end

generic do
generic loop
generic until
generic while
generic wend

generic for
generic to
generic step
generic next

generic select
generic case

# functions with return type none are subs
function abs            integer   integer
function abs            long      long
function abs            integer64 integer64
function abs            single    single
function abs            double    double
function abs            quad      quad
function asc            integer   string,integer64?
function beep           none
function chr            string    integer
function cls            none
function input          none      list
function int            single    single
function int            double    double
function int            quad      quad
function fix            single    single
function fix            double    double
function fix            quad      quad
function left           string    string,integer64
function mid            string    string,integer64,integer64?
function play           none      string
function print          none      list
function right          string    string,integer64
function sound          none      double,double
function system         none      integer
