'Copyright 2020 Luke Ceddia
'SPDX-License-Identifier: Apache-2.0
'parser.bm - Recursive Descent Parser

function ps_is_linejoin
    ps_is_linejoin = tok_token = TOK_NEWLINE and tok_content$ = ":"
end function
    
sub ps_consume(expected)
    ps_assert expected
    tok_advance
end sub

function ps_consumed(expected)
    if tok_token = expected then
        if tok_token = TOK_NEWLINE and not ps_is_linejoin then ps_actual_linenum = ps_actual_linenum + 1
        tok_advance
        ps_consumed = TRUE
    end if
end function

sub ps_assert(expected)
    if tok_token <> expected then
        ps_error "Syntax error: expected " + tok_human_readable(expected) + " got " + tok_human_readable(tok_token)
    else
        debuginfo "Assert " + tok_human_readable(expected)
    end if
    if tok_token = TOK_NEWLINE and not ps_is_linejoin then ps_actual_linenum = ps_actual_linenum + 1
end sub

function ps_is_terminator(t)
    select case t
    case TOK_ELSE, TOK_NEWLINE
        ps_is_terminator = TRUE
    end select
end function

sub ps_assert_not_const(var)
    if symtab(var).v3 then ps_error "Cannot modify CONST"
end sub

sub ps_attach_labels(node)
    if node > 0 then
        for i = 1 to len(ps_unattached_labels$) step 4
            label_id = cvl(mid$(ps_unattached_labels$, i, 4))
            debuginfo "Attached label " + symtab(label_id).identifier
            symtab(label_id).v1 = node
            'Have we resolved an unresolved jump?
            for j = 1 to len(ps_unresolved_jumps$) step 4
                unres_node = cvl(mid$(ps_unresolved_jumps$, j, 4))
                if ast_nodes(unres_node).ref = label_id then
                    ast_nodes(unres_node).ref = node
                else
                    still_unres$ = still_unres$ + mkl$(unres_node)
                end if
            next j
            ps_unresolved_jumps$ = still_unres$
        next i
        ps_unattached_labels$ = ""
    end if
end sub

'Handles any labels not yet attached by the end of the program, because
'they're trailing empty lines or trailing non-executable statements.
'Also ensures all references point to an existent label.
sub ps_finish_labels(block)
    if len(ps_unattached_labels$) > 0 then
        end_node = ast_add_node(AST_BLOCK)
        ast_attach block, end_node
        ps_attach_labels end_node
    end if 
    if len(ps_unresolved_jumps$) then
        labels$ = symtab(ast_nodes(cvl(left$(ps_unresolved_jumps$, 4))).ref).identifier
        for i = 5 to len(ps_unresolved_jumps$) step 4
            labels$ = ", " + symtab(ast_nodes(cvl(mid$(ps_unresolved_jumps$, i, 4))).ref).identifier
        next i
        ps_error "Undefined label(s): " + labels$
    end if
end sub

'Expects: first token in block
'Results: block end marker or EOF
function ps_block
    debuginfo "Start block"
    root = ast_add_node(AST_BLOCK)
    do
        do while tok_token = TOK_NEWLINE
            ps_consume TOK_NEWLINE
        loop
        stmt = ps_stmt
        if stmt = -1 then exit do 'use -1 to signal the end of a block
        if stmt then ast_attach root, stmt '0 means that statement did not generate any ast nodes
    loop
    ps_block = root
    debuginfo "End block"
end function

'Expects: first token of statement
'Results: NEWLINE or block end marker
function ps_stmt
    'This part only relevant for interactive mode
    do while tok_token = TOK_NEWLINE
        ps_consume TOK_NEWLINE
    loop
    if tok_token = TOK_EOI then
        ps_consume TOK_EOI
    end if

    if tok_token = TOK_LINENUM then ps_label
    debuginfo "Start statement"
    select case tok_token
        case is < 0
            ps_error "Unexpected literal " + tok_content$
        case TOK_IF
            stmt = ps_if
        case TOK_DO
            stmt = ps_do
        case TOK_WHILE
            stmt = ps_while
        case TOK_FOR
            stmt = ps_for
        case TOK_SELECT
            stmt = ps_select
        case TOK_PRINT
            stmt = ps_print
        case TOK_INPUT
            stmt = ps_stmt_input
        case TOK_DIM
            stmt = ps_dim
        case TOK_CONST
            stmt = ps_const
        case TOK_GOTO
            stmt = ps_goto
        case TOK_END, TOK_ELSE, TOK_ELSEIF, TOK_LOOP, TOK_WEND, TOK_NEXT, TOK_CASE, TOK_EOF 
            'These all end a block in some fashion. The block-specific
            ' code will assert the ending token.
            stmt = -1
        case TOK_UNKNOWN
            stmt = ps_assignment
        case TOK_NEWLINE
            'Blank line; ignore it
            stmt = 0
        case else
            select case symtab(tok_token).typ
            case SYM_VARIABLE
                stmt = ps_assignment
            case SYM_FUNCTION
                stmt = ps_stmtreg
            case else
                ps_error tok_human_readable$(tok_token) + " (" + tok_content$ + ") doesn't belong here"
            end select
    end select

    ps_attach_labels stmt

    ps_stmt = stmt
    debuginfo "Completed statement"
end function

'Expects: TOK_LINENUM
'Results: next token
'Note: this is for label definitions, not references
sub ps_label
    debuginfo "Start label"
    id = symtab_get_id(tok_content$)
    if id > 0 and symtab(id).typ <> SYM_LABEL then
        ps_error "Label name conflicts with existing identifier"
    elseif id > 0 and symtab(id).v2 = TRUE then
        ps_error "Label already defined"
    elseif id > 0 then
        'This is a label that was only referenced until now; mark it found
        symtab(id).v2 = TRUE
    else
        dim symtab_label as symtab_entry_t
        symtab_label.identifier = tok_content$
        symtab_label.typ = SYM_LABEL
        symtab_label.v2 = TRUE
        symtab_add_entry symtab_label
        id = symtab_last_entry
    end if
    ps_unattached_labels$ = ps_unattached_labels$ + mkl$(id)
    ps_consume TOK_LINENUM
    debuginfo "Completed label"
end sub

'Expects: GOTO
'Results: token after line number
function ps_goto
    ps_consume TOK_GOTO
    ps_goto = ps_goto_p
end function

'Expects: line number
'Results: token after line number
function ps_goto_p
    debuginfo "Start goto"
    ps_assert TOK_NUMINT
    root = ast_add_node(AST_GOTO)
    id = symtab_get_id(tok_content$)
    if id > 0 and symtab(id).v2 = TRUE and symtab(id).v1 > 0 then
        'Label exists, is resolved and is attached
        debuginfo "Goto resolves to" + str$(symtab(id).v1)
        ast_nodes(root).ref = symtab(id).v1
    elseif id > 0 then
        'This case helps with things like "10 GOTO 10" (label resolved but not attached)
        debuginfo "Reference to pre-existing unresolved or unattached label"
        ast_nodes(root).ref = id
        ps_unresolved_jumps$ = ps_unresolved_jumps$ + mkl$(root)
    else
        debuginfo "Unresolved goto"
        dim symtab_label as symtab_entry_t
        symtab_label.identifier = tok_content$
        symtab_label.typ = SYM_LABEL
        symtab_add_entry symtab_label
        'Unresolved, so point directly to the label
        ast_nodes(root).ref = symtab_last_entry
        ps_unresolved_jumps$ = ps_unresolved_jumps$ + mkl$(root)
    end if
    ps_consume TOK_NUMINT
    ps_goto_p = root
    debuginfo "Completed goto"
end function

    
'Expects: FOR
'Results: NEWLINE after NEXT or iterator variable
function ps_for
    debuginfo "Start FOR loop"
    root = ast_add_node(AST_FOR)
    ps_consume TOK_FOR
    var = ps_variable
    var_type = symtab(var).v1
    if not type_is_number(var_type) then ps_error "FOR iterator variable must be numeric"
    ast_nodes(root).ref = var
    ps_consume TOK_EQUALS

    start_val = ps_expr
    if not type_is_number(type_of_expr(start_val)) then ps_error "FOR start value must be numeric"
    if type_of_expr(start_val) <> var_type then
        cast = ast_add_node(AST_CAST)
        ast_nodes(cast).ref = var_type
        ast_attach cast, start_val
        start_val = cast
    end if
    ps_consume TOK_TO

    end_val = ps_expr
    if not type_is_number(type_of_expr(end_val)) then ps_error "FOR end value must be numeric"
    if type_of_expr(end_val) <> var_type then
        cast = ast_add_node(AST_CAST)
        ast_nodes(cast).ref = var_type
        ast_attach cast, end_val
        end_val = cast
    end if

    if tok_token = TOK_STEP then
        ps_consume TOK_STEP
        step_val = ps_expr
        if not type_is_number(type_of_expr(step_val)) then ps_error "FOR STEP value must be numeric"
    else
        step_val = ast_add_node(AST_CONSTANT)
        ast_nodes(step_val).ref = AST_ONE
    end if
    if type_of_expr(step_val) <> var_type then
        cast = ast_add_node(AST_CAST)
        ast_nodes(cast).ref = var_type
        ast_attach cast, step_val
        step_val = cast
    end if
    ps_consume TOK_NEWLINE

    ast_attach root, start_val
    ast_attach root, end_val
    ast_attach root, step_val
    ast_attach root, ps_block

    ps_consume TOK_NEXT
    if tok_token <> TOK_NEWLINE then
        check_var = ps_variable
        if check_var <> var then ps_error "NEXT variable does not match FOR variable"
    end if

    ps_for = root
    debuginfo "Completed FOR loop"
end function

'Expects: WHILE
'Results: NEWLINE after WEND
function ps_while
    debuginfo "Start WHILE loop"
    root = ast_add_node(AST_DO_PRE)
    ps_consume TOK_WHILE
    ast_attach root, ps_expr
    ps_consume TOK_NEWLINE

    ast_attach root, ps_block
    ps_consume TOK_WEND

    ps_while = root
    debuginfo "Completed WHILE loop"
end function

'Expects: DO
'Results: NEWLINE after LOOP or condition
function ps_do
    debuginfo "Start DO loop"
    ps_consume TOK_DO
    if tok_token = TOK_WHILE or tok_token = TOK_UNTIL then ps_do = ps_do_pre else ps_do = ps_do_post
    debuginfo "Completed DO loop"
end function

'Expects: WHILE or UNTIL
'Results: NEWLINE after LOOP
function ps_do_pre
    debuginfo "Start DO-pre loop"
    root = ast_add_node(AST_DO_PRE)
    if tok_token = TOK_UNTIL then
        ps_consume TOK_UNTIL
        'Need to invert guard condition
        guard = ast_add_node(AST_CALL)
        ast_nodes(guard).ref = TOK_EQUALS
        ast_nodes(guard).ref2 = type_find_sig_match(TOK_EQUALS, mkl$(TYPE_INTEGER) + mkl$(0) + mkl$(TYPE_INTEGER) + mkl$(0))
        ast_attach guard, ps_expr
        f = ast_add_node(AST_CONSTANT)
        ast_nodes(f).ref = AST_FALSE
        ast_attach guard, f
    else
        ps_consume TOK_WHILE
        guard = ps_expr
    end if
    ast_attach root, guard
    ps_consume TOK_NEWLINE

    ast_attach root, ps_block
    ps_consume TOK_LOOP

    ps_do_pre = root
    debuginfo "Completed DO-pre loop"
end function

'Expects: NEWLINE
'Results: NEWLINE after loop guard condition
function ps_do_post
    debuginfo "Start DO-post loop"
    ps_consume TOK_NEWLINE
    root = ast_add_node(AST_DO_POST)
    block = ps_block

    ps_consume TOK_LOOP
    if tok_token = TOK_UNTIL then
        ps_consume TOK_UNTIL
        'Need to invert guard condition
        guard = ast_add_node(AST_CALL)
        ast_nodes(guard).ref = TOK_EQUALS
        ast_nodes(guard).ref2 = type_find_sig_match(TOK_EQUALS, mkl$(TYPE_INTEGER) + mkl$(0) + mkl$(TYPE_INTEGER) + mkl$(0))
        ast_attach guard, ps_expr
        f = ast_add_node(AST_CONSTANT)
        ast_nodes(f).ref = AST_FALSE
        ast_attach guard, f
    elseif tok_token = TOK_WHILE then
        ps_consume TOK_WHILE
        guard = ps_expr
    else
        'Infinite loop
        guard = ast_add_node(AST_CONSTANT)
        ast_nodes(guard).ref = AST_TRUE
    end if
    ast_attach root, guard
    ast_attach root, block

    ps_do_post = root
    debuginfo "Completed DO-post loop"
end function

'Expects: IF
'Results: newline
function ps_if
    debuginfo "Start conditional"
    root = ast_add_node(AST_IF)
    ps_consume TOK_IF

    condition = ps_expr
    if not type_is_number(type_of_expr(condition)) then ps_error "Condition must be a numeric expression"
    ast_attach root, condition
    ps_consume TOK_THEN

    'A REM after THEN acts as a command; we remain in single-line if mode
    if ucase$(tok_content$) = "REM" then
        block = ast_add_node(AST_BLOCK)
        ast_attach root, block
        ps_if = root
        debuginfo "Completed conditional (single-line REM)"
        exit function
    end if

    if tok_token <> TOK_NEWLINE or ps_is_linejoin then
        debuginfo "Single-line IF"
        ast_attach root, ps_if_stmts
        if tok_token = TOK_ELSE then
            ps_consume TOK_ELSE
            ast_attach root, ps_if_stmts
        end if
    else
        debuginfo "Multi-line IF"
        ast_attach root, ps_block
        do while tok_token = TOK_ELSEIF
            ps_consume TOK_ELSEIF
            condition = ps_expr
            if not type_is_number(type_of_expr(condition)) then ps_error "Condition must be a numeric expression"
            ast_attach root, condition
            ps_consume TOK_THEN
            ast_attach root, ps_block
        loop
        if tok_token = TOK_ELSE then
            ps_consume TOK_ELSE
            ast_attach root, ps_block 
        end if
        ps_consume TOK_END
        ps_consume TOK_IF
    end if

    ps_if = root
    debuginfo "Completed conditional"
end function

'Expects: Start of a statement or :
'Results: ELSE or NEWLINE
'Note: This handles one or more statements joined by : and terminated by ELSE/NEWLINE, or an implicit GOTO
function ps_if_stmts
    debuginfo "Start if stmts"
    block = ast_add_node(AST_BLOCK)
    if tok_token = TOK_NUMINT then
        ast_attach block, ps_goto_p
    else
        do
            while ps_is_linejoin
                ps_consume TOK_NEWLINE
            wend
            stmt = ps_stmt
            ast_attach block, stmt
            while ps_is_linejoin
                ps_consume TOK_NEWLINE
            wend
        loop until ps_is_terminator(tok_token)
    end if
    ps_if_stmts = block
    debuginfo "Completed if stmts"
end function
    
'Expects: TOK_DIM
'Results: token after last declaration
'Format: DIM variablelist
function ps_dim
    debuginfo "Start dim"
    ps_consume TOK_DIM
    do
        ps_assert_not_const ps_variable
    loop while ps_consumed(TOK_COMMA)
    ps_dim = 0
    debuginfo "Completed dim"
end function

'Expects: TOK_PRINT
'Results: token after last expression, comma or semicolon
'Format: PRINT [expressionlist][{,|;}]
function ps_print
    debuginfo "Start print"
    root = ast_add_node(AST_CALL)
    ast_nodes(root).ref = TOK_PRINT
    ast_nodes(root).ref2 = symtab(TOK_PRINT).v1
    ps_consume TOK_PRINT

    newline = TRUE
    do
        if ps_is_terminator(tok_token) then exit do
        select case tok_token
        case TOK_COMMA
            node = ast_add_node(AST_FLAGS)
            ast_nodes(node).ref = PRINT_NEXT_FIELD
            ast_attach root, node
            ps_consume TOK_COMMA
            newline = FALSE
        case TOK_SEMICOLON
            'No flags needed here
            ps_consume TOK_SEMICOLON
            newline = FALSE
        case else
            ast_attach root, ps_expr
            newline = TRUE
        end select
    loop
    if newline then
        node = ast_add_node(AST_FLAGS)
        ast_nodes(node).ref = PRINT_NEWLINE
        ast_attach root, node
    end if
    
    ps_print = root
    debuginfo "Completed print"
end function

'Expects: TOK_INPUT
'Results: token after input variables
'Format: INPUT[;]["prompt"{;|,}]variablelist
function ps_stmt_input
    debuginfo "Start stmt input"
    root = ast_add_node(AST_CALL)
    ast_nodes(root).ref = TOK_INPUT
    ast_nodes(root).ref2 = symtab(TOK_INPUT).v1
    flags = ast_add_node(AST_FLAGS)
    ast_attach root, flags
    ps_consume TOK_INPUT

    if tok_token = TOK_SEMICOLON then
        ast_nodes(flags).ref = STMT_INPUT_NO_NEWLINE
        ps_consume TOK_SEMICOLON
    end if

    'The prompt must be a literal string, no expressions. Crazy, right?
    if tok_token = TOK_STRINGLIT then
        prompt = ast_add_node(AST_CONSTANT)
        ast_nodes(prompt).ref = ast_add_constant(tok_token, tok_content$, TYPE_STRINGLIT)
        ast_nodes(flags).ref = ast_nodes(flags).ref OR STMT_INPUT_PROMPT
        ast_attach root, prompt
        ps_consume TOK_STRINGLIT
        if tok_token = TOK_COMMA then
            ast_nodes(flags).ref = ast_nodes(flags).ref OR STMT_INPUT_NO_QUESTION
            ps_consume TOK_COMMA
        else
            ps_consume TOK_SEMICOLON
        end if
    end if

    do
        var = ast_add_node(AST_VAR)
        ast_nodes(var).ref = ps_variable
        ps_assert_not_const ast_nodes(var).ref
        ast_attach root, var
    loop while ps_consumed(TOK_COMMA)

    ps_stmt_input = root
    debuginfo "Completed stmt input"
end function
 
'Expects: TOK_CONST
'Results: token after rvalue
function ps_const
    debuginfo "Start const"
    ps_consume TOK_CONST
    if tok_token <> TOK_UNKNOWN then ps_error "CONST already defined"
    'Change default type because we want to infer it from the rvalue
    prev_default = ps_default_type
    ps_default_type = TYPE_NONE
    ref = ps_variable
    ps_default_type = prev_default
    symtab(ref).v3 = TRUE 'Mark constant

    root = ast_add_node(AST_ASSIGN)
    ast_nodes(root).ref = ref
    ps_consume TOK_EQUALS

    expr = ps_expr
    if symtab(ref).v1 = TYPE_NONE then
        symtab(ref).v1 = type_of_expr(expr)
        ast_attach root, expr
    elseif type_can_cast(symtab(ref).v1, type_of_expr(expr)) then
        cast = ast_add_node(AST_CAST)
        ast_nodes(cast).ref = symtab(ref).v1
        ast_attach cast, expr
        ast_attach root, cast
    else
        ps_error "Type mismatch"
    end if

    ps_const = root
    debuginfo "Completed const"
end function

'Expects: lvalue token
'Results: token after rvalue
function ps_assignment
    debuginfo "Start assignment"
    ref = ps_variable
    ps_assert_not_const ref
    root = ast_add_node(AST_ASSIGN)
    ast_nodes(root).ref = ref
    ps_consume TOK_EQUALS

    expr = ps_expr
    lvalue_type = symtab(ref).v1
    rvalue_type = type_of_expr(expr)
    if not type_can_cast(lvalue_type, rvalue_type) then ps_error "Type of variable in assignment does not match value being assigned"
    expr = ast_add_cast(expr, lvalue_type)
    ast_attach root, expr

    ps_assignment = root
    debuginfo "Completed assignment"
end function

'Expects: variable token
'Results: token after variable & sigil
function ps_variable
    token = tok_token
    content$ = tok_content$
    tok_advance
    ps_variable = ps_variable_p(token, content$)
end function

'Expects: token after variable, variable token as arg
'Results: post token
function ps_variable_p(token, content$)
    debuginfo "Start variable"
    dim sym as symtab_entry_t
    'Do array & udt element stuff here.
    'For now only support simple variables.
  
    'New variable?
    if token = TOK_UNKNOWN then
        ucase_content$ = ucase$(content$)
        s = symtab_get_id(ucase_content$)
        if s then
            'Slight hack: in the case of something like A = A + 1 where A is previously defined, tokeng will fail
            'to identify the second A as an existing variable because it is looking ahead. So, we check again here
            'to confirm it's a new variable.
            var = s
        else
            sym.identifier = ucase_content$
            sym.typ = SYM_VARIABLE
            sym.v1 = ps_default_type
            ps_last_var_index = ps_last_var_index + 1
            sym.v2 = ps_last_var_index
            symtab_add_entry sym
            var = symtab_last_entry
        end if
    else
        var = token
    end if

    'Check for type sigil
    sigil = ps_opt_sigil
    if sigil then
        if token <> TOK_UNKNOWN and sigil <> symtab(var).v1 then ps_error "Type suffix does not match existing variable type"
        'Otherwise it's a new variable; set its type
        symtab(var).v1 = sigil
    end if
    ps_variable_p = var
    debuginfo "Completed variable"
end function

'Expects: sigil or otherwise
'Results: post token if sigil present, unchanged otherwise
function ps_opt_sigil
    debuginfo "Start optional sigil"
    if tok_token = TOK_AS then ps_consume TOK_AS
    typ = type_tok2type(tok_token)
    if typ then
        ps_opt_sigil = typ
        tok_advance
    else
        ps_opt_sigil = 0
    end if
    debuginfo "Completed optional sigil"
end function

'Expects: first token of expr
'Results: token after expression
'Note: the expression parser is greedy; it will only stop when it encounters
'      a token that cannot possibly be part of an expression.
function ps_expr
    debuginfo "Start expr"
    ps_expr = pt_expr(0)
    debuginfo "Completed expr"
end function
        
'Expects: statement token
'Results: token after last argument
function ps_stmtreg
    debuginfo "Start stmtreg"
    root = ast_add_node(AST_CALL)
    ast_nodes(root).ref = tok_token

    tok_advance
    ps_funcargs root

    ps_stmtreg = root
    debuginfo "Completed stmtreg"
end function

'Expects: function token
'Results: token after last argument
function ps_funccall
    token = tok_token
    tok_advance
    ps_funccall = ps_funccall_p(token)
end function

'Expects: token after function, function token as arg
'Results: token after last argument
function ps_funccall_p(func)
    debuginfo "Start function call"
    root = ast_add_node(AST_CALL)
    ast_nodes(root).ref = func
    sigil = ps_opt_sigil
    if tok_token = TOK_OPAREN then
        ps_consume TOK_OPAREN
        ps_funcargs root
        ps_consume TOK_CPAREN
    end if
    if sigil > 0 and sigil <> type_of_call(root) then ps_error "Function must have correct type suffix if present"
    ps_funccall_p = root
    debuginfo "Completed function call"
end function

'Expects: first token after function name
'Results: token after argument list
sub ps_funcargs(root)
    debuginfo "Start funcargs"
    'This code first builds a candidate type signature, then tries to match that against an instance signature.
    func = ast_nodes(root).ref
    do
        if ps_is_terminator(tok_token) or tok_token = TOK_CPAREN then exit do
        select case tok_token
        case TOK_COMMA
            ps_consume TOK_COMMA
            ps_funcarg root, candidate$
        case else
            ps_funcarg root, candidate$
        end select
    loop

    'Now we need to find a signature of func that matches candidate$.
    matching_sig = type_find_sig_match(func, candidate$)
    if matching_sig = 0 then ps_error "Cannot find matching type signature"
    ast_nodes(root).ref2 = matching_sig
    'Modify argument nodes to add in casts where needed
    for i = 1 to ast_num_children(root)
        expr = ast_get_child(root, i)
        expr_type = type_of_expr(expr)
        arg_type = type_sig_argtype(matching_sig, i)
        if expr_type <> arg_type then
            ast_replace_child root, i, ast_add_cast(expr, arg_type)
        end if
    next i
    debuginfo "Completed funcargs"
end sub

'Expects: start of expression
'Results: token after expression
sub ps_funcarg(root, candidate$)
    debuginfo "Start funcarg"
    expr = ps_expr
    'Declare whether this expression would satisfy a BYREF argument
    if ast_nodes(expr).typ = AST_VAR then flags = TYPE_BYREF
    candidate$ = type_sig_add_arg$(candidate$, type_of_expr(expr), flags)
    ast_attach root, expr
    debuginfo "Completed funcarg"
end sub

sub ps_error(msg$)
    Error_message$ = msg$
    error 101
end sub

'$include: 'pratt.bm'
'$include: 'tokeng.bm'
