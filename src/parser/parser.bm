'Copyright 2020 Luke Ceddia
'SPDX-License-Identifier: Apache-2.0
'parser.bm - Recursive Descent Parser

sub ps_consume(expected)
    ps_assert expected
    if expected = TOK_NEWLINE then ps_actual_linenum = ps_actual_linenum + 1
    tok_advance
end sub

function ps_consumed(expected)
    if tok_token = expected then
        tok_advance
        ps_consumed = TRUE
    end if
end function

sub ps_assert(expected)
    if tok_token <> expected then
        ps_error "Syntax error: expected " + tok_human_readable(expected) + " got " + tok_human_readable(tok_token)
    else
        debuginfo "Assert " + tok_human_readable(expected)
    end if
end sub

function ps_is_terminator(t)
    select case t
    case TOK_ELSE, TOK_NEWLINE
        ps_is_terminator = TRUE
    end select
end function

sub ps_assert_not_const(var)
    if symtab(var).v3 then ps_error "Cannot modify CONST"
end sub

'Expects: first token in block
'Results: block end marker or EOF
function ps_block
    debuginfo "Start block"
    root = ast_add_node(AST_BLOCK)
    do
        do while tok_token = TOK_NEWLINE
            ps_consume TOK_NEWLINE
        loop
        stmt = ps_stmt
        if stmt = -1 then exit do 'use -1 to signal the end of a block
        if stmt then ast_attach root, stmt '0 means that statement did not generate any ast nodes
    loop
    ps_block = root
    debuginfo "End block"
end function

'Expects: first token of statement
'Results: NEWLINE or block end marker
function ps_stmt
    'This line only relevant for interactive mode
    if tok_token = TOK_EOI then ps_consume TOK_EOI

    debuginfo "Start statement"
    select case tok_token
        case is < 0
            ps_error "Unexpected literal " + tok_content$
        case TOK_IF
            ps_stmt = ps_if
        case TOK_DO
            ps_stmt = ps_do
        case TOK_WHILE
            ps_stmt = ps_while
        case TOK_FOR
            ps_stmt = ps_for
        case TOK_SELECT
            ps_stmt = ps_select
        case TOK_PRINT
            ps_stmt = ps_print
        case TOK_INPUT
            ps_stmt = ps_stmt_input
        case TOK_DIM
            ps_stmt = ps_dim
        case TOK_CONST
            ps_stmt = ps_const
        case TOK_END, TOK_ELSE, TOK_LOOP, TOK_WEND, TOK_NEXT, TOK_CASE, TOK_EOF 
            'These all end a block in some fashion. The block-specific
            ' code will assert the ending token.
            ps_stmt = -1
        case TOK_UNKNOWN
            ps_stmt = ps_assignment
        case else
            select case symtab(tok_token).typ
            case SYM_VARIABLE
                ps_stmt = ps_assignment
            case SYM_FUNCTION
                ps_stmt = ps_stmtreg
            case else
                ps_error tok_human_readable$(tok_token) + " (" + tok_content$ + ") doesn't belong here"
            end select
    end select
    debuginfo "Completed statement"
end function

'Expects: FOR
'Results: NEWLINE after NEXT or iterator variable
function ps_for
    debuginfo "Start FOR loop"
    root = ast_add_node(AST_FOR)
    ps_consume TOK_FOR
    var = ps_variable
    var_type = symtab(var).v1
    if not type_is_number(var_type) then ps_error "FOR iterator variable must be numeric"
    ast_nodes(root).ref = var
    ps_consume TOK_EQUALS

    start_val = ps_expr
    if not type_is_number(type_of_expr(start_val)) then ps_error "FOR start value must be numeric"
    if type_of_expr(start_val) <> var_type then
        cast = ast_add_node(AST_CAST)
        ast_nodes(cast).ref = var_type
        ast_attach cast, start_val
        start_val = cast
    end if
    ps_consume TOK_TO

    end_val = ps_expr
    if not type_is_number(type_of_expr(end_val)) then ps_error "FOR end value must be numeric"
    if type_of_expr(end_val) <> var_type then
        cast = ast_add_node(AST_CAST)
        ast_nodes(cast).ref = var_type
        ast_attach cast, end_val
        end_val = cast
    end if

    if tok_token = TOK_STEP then
        ps_consume TOK_STEP
        step_val = ps_expr
        if not type_is_number(type_of_expr(step_val)) then ps_error "FOR STEP value must be numeric"
    else
        step_val = ast_add_node(AST_CONSTANT)
        ast_nodes(step_val).ref = AST_ONE
    end if
    if type_of_expr(step_val) <> var_type then
        cast = ast_add_node(AST_CAST)
        ast_nodes(cast).ref = var_type
        ast_attach cast, step_val
        step_val = cast
    end if
    ps_consume TOK_NEWLINE

    ast_attach root, start_val
    ast_attach root, end_val
    ast_attach root, step_val
    ast_attach root, ps_block

    ps_consume TOK_NEXT
    if tok_token <> TOK_NEWLINE then
        check_var = ps_variable
        if check_var <> var then ps_error "NEXT variable does not match FOR variable"
    end if

    ps_for = root
    debuginfo "Completed FOR loop"
end function

'Expects: WHILE
'Results: NEWLINE after WEND
function ps_while
    debuginfo "Start WHILE loop"
    root = ast_add_node(AST_DO_PRE)
    ps_consume TOK_WHILE
    ast_attach root, ps_expr
    ps_consume TOK_NEWLINE

    ast_attach root, ps_block
    ps_consume TOK_WEND

    ps_while = root
    debuginfo "Completed WHILE loop"
end function

'Expects: DO
'Results: NEWLINE after LOOP or condition
function ps_do
    debuginfo "Start DO loop"
    ps_consume TOK_DO
    if tok_token = TOK_WHILE or tok_token = TOK_UNTIL then ps_do = ps_do_pre else ps_do = ps_do_post
    debuginfo "Completed DO loop"
end function

'Expects: WHILE or UNTIL
'Results: NEWLINE after LOOP
function ps_do_pre
    debuginfo "Start DO-pre loop"
    root = ast_add_node(AST_DO_PRE)
    if tok_token = TOK_UNTIL then
        ps_consume TOK_UNTIL
        'Need to invert guard condition
        guard = ast_add_node(AST_CALL)
        ast_nodes(guard).ref = TOK_EQUALS
        ast_nodes(guard).ref2 = type_find_sig_match(TOK_EQUALS, mkl$(TYPE_INTEGER) + mkl$(0) + mkl$(TYPE_INTEGER) + mkl$(0))
        ast_attach guard, ps_expr
        f = ast_add_node(AST_CONSTANT)
        ast_nodes(f).ref = AST_FALSE
        ast_attach guard, f
    else
        ps_consume TOK_WHILE
        guard = ps_expr
    end if
    ast_attach root, guard
    ps_consume TOK_NEWLINE

    ast_attach root, ps_block
    ps_consume TOK_LOOP

    ps_do_pre = root
    debuginfo "Completed DO-pre loop"
end function

'Expects: NEWLINE
'Results: NEWLINE after loop guard condition
function ps_do_post
    debuginfo "Start DO-post loop"
    ps_consume TOK_NEWLINE
    root = ast_add_node(AST_DO_POST)
    block = ps_block

    ps_consume TOK_LOOP
    if tok_token = TOK_UNTIL then
        ps_consume TOK_UNTIL
        'Need to invert guard condition
        guard = ast_add_node(AST_CALL)
        ast_nodes(guard).ref = TOK_EQUALS
        ast_nodes(guard).ref2 = type_find_sig_match(TOK_EQUALS, mkl$(TYPE_INTEGER) + mkl$(0) + mkl$(TYPE_INTEGER) + mkl$(0))
        ast_attach guard, ps_expr
        f = ast_add_node(AST_CONSTANT)
        ast_nodes(f).ref = AST_FALSE
        ast_attach guard, f
    elseif tok_token = TOK_WHILE then
        ps_consume TOK_WHILE
        guard = ps_expr
    else
        'Infinite loop
        guard = ast_add_node(AST_CONSTANT)
        ast_nodes(guard).ref = AST_TRUE
    end if
    ast_attach root, guard
    ast_attach root, block

    ps_do_post = root
    debuginfo "Completed DO-post loop"
end function

'Expects: IF
'Results: NEWLINE or post token for nested single-line IFs
function ps_if
    debuginfo "Start conditional"
    root = ast_add_node(AST_IF)
    tok_advance

    condition = ps_expr
    if not type_is_number(type_of_expr(condition)) then ps_error "IF condition must be a numeric expression"
    ast_attach root, condition
    ps_consume TOK_THEN

    rem_present = ucase$(tok_content$) = "REM"
    if tok_token = TOK_NEWLINE and not rem_present then 'Multi-line if
        debuginfo "Multi-line conditional"
        ps_actual_linenum = ps_actual_linenum + 1
        tok_advance
        ast_attach root, ps_block
        if tok_token = TOK_ELSE then
            'Point of contention! QB45 insists on this newline, QB64 doesn't. We shall insist.
            tok_advance
            ps_consume TOK_NEWLINE
            ast_attach root, ps_block
        end if
        ps_consume TOK_END
        ps_consume TOK_IF
    else
        debuginfo "Single-line conditional"
        if rem_present then
            ast_attach root, ast_add_node(AST_BLOCK)
        else
            ast_attach root, ps_stmt
            if tok_token = TOK_ELSE then
                tok_advance
                ast_attach root, ps_stmt
            end if
        end if
    end if
    ps_if = root
    debuginfo "Completed conditional"
end function
    
'Expects: TOK_DIM
'Results: token after last declaration
'Format: DIM variablelist
function ps_dim
    debuginfo "Start dim"
    ps_consume TOK_DIM
    do
        ps_assert_not_const ps_variable
    loop while ps_consumed(TOK_COMMA)
    ps_dim = 0
    debuginfo "Completed dim"
end function

'Expects: TOK_PRINT
'Results: token after last expression, comma or semicolon
'Format: PRINT [expressionlist][{,|;}]
function ps_print
    debuginfo "Start print"
    root = ast_add_node(AST_CALL)
    ast_nodes(root).ref = TOK_PRINT
    ast_nodes(root).ref2 = symtab(TOK_PRINT).v1
    ps_consume TOK_PRINT

    newline = TRUE
    do
        if ps_is_terminator(tok_token) then exit do
        select case tok_token
        case TOK_COMMA
            node = ast_add_node(AST_FLAGS)
            ast_nodes(node).ref = PRINT_NEXT_FIELD
            ast_attach root, node
            ps_consume TOK_COMMA
            newline = FALSE
        case TOK_SEMICOLON
            'No flags needed here
            ps_consume TOK_SEMICOLON
            newline = FALSE
        case else
            ast_attach root, ps_expr
            newline = TRUE
        end select
    loop
    if newline then
        node = ast_add_node(AST_FLAGS)
        ast_nodes(node).ref = PRINT_NEWLINE
        ast_attach root, node
    end if
    
    ps_print = root
    debuginfo "Completed print"
end function

'Expects: TOK_INPUT
'Results: token after input variables
'Format: INPUT[;]["prompt"{;|,}]variablelist
function ps_stmt_input
    debuginfo "Start stmt input"
    root = ast_add_node(AST_CALL)
    ast_nodes(root).ref = TOK_INPUT
    ast_nodes(root).ref2 = symtab(TOK_INPUT).v1
    flags = ast_add_node(AST_FLAGS)
    ast_attach root, flags
    ps_consume TOK_INPUT

    if tok_token = TOK_SEMICOLON then
        ast_nodes(flags).ref = STMT_INPUT_NO_NEWLINE
        ps_consume TOK_SEMICOLON
    end if

    'The prompt must be a literal string, no expressions. Crazy, right?
    if tok_token = TOK_STRINGLIT then
        prompt = ast_add_node(AST_CONSTANT)
        ast_nodes(prompt).ref = ast_add_constant(tok_token, tok_content$, TYPE_STRINGLIT)
        ast_nodes(flags).ref = ast_nodes(flags).ref OR STMT_INPUT_PROMPT
        ast_attach root, prompt
        ps_consume TOK_STRINGLIT
        if tok_token = TOK_COMMA then
            ast_nodes(flags).ref = ast_nodes(flags).ref OR STMT_INPUT_NO_QUESTION
            ps_consume TOK_COMMA
        else
            ps_consume TOK_SEMICOLON
        end if
    end if

    do
        var = ast_add_node(AST_VAR)
        ast_nodes(var).ref = ps_variable
        ps_assert_not_const ast_nodes(var).ref
        ast_attach root, var
    loop while ps_consumed(TOK_COMMA)

    ps_stmt_input = root
    debuginfo "Completed stmt input"
end function
 
'Expects: TOK_CONST
'Results: token after rvalue
function ps_const
    debuginfo "Start const"
    ps_consume TOK_CONST
    if tok_token <> TOK_UNKNOWN then ps_error "CONST already defined"
    'Change default type because we want to infer it from the rvalue
    prev_default = ps_default_type
    ps_default_type = TYPE_NONE
    ref = ps_variable
    ps_default_type = prev_default
    symtab(ref).v3 = TRUE 'Mark constant

    root = ast_add_node(AST_ASSIGN)
    ast_nodes(root).ref = ref
    ps_consume TOK_EQUALS

    expr = ps_expr
    if symtab(ref).v1 = TYPE_NONE then
        symtab(ref).v1 = type_of_expr(expr)
        ast_attach root, expr
    elseif type_can_cast(symtab(ref).v1, type_of_expr(expr)) then
        cast = ast_add_node(AST_CAST)
        ast_nodes(cast).ref = symtab(ref).v1
        ast_attach cast, expr
        ast_attach root, cast
    else
        ps_error "Type mismatch"
    end if

    ps_const = root
    debuginfo "Completed const"
end function

'Expects: lvalue token
'Results: token after rvalue
function ps_assignment
    debuginfo "Start assignment"
    ref = ps_variable
    ps_assert_not_const ref
    root = ast_add_node(AST_ASSIGN)
    ast_nodes(root).ref = ref
    ps_consume TOK_EQUALS

    expr = ps_expr
    lvalue_type = symtab(ref).v1
    rvalue_type = type_of_expr(expr)
    if not type_can_cast(lvalue_type, rvalue_type) then ps_error "Type of variable in assignment does not match value being assigned"
    expr = ast_add_cast(expr, lvalue_type)
    ast_attach root, expr

    ps_assignment = root
    debuginfo "Completed assignment"
end function

'Expects: variable token
'Results: token after variable & sigil
function ps_variable
    token = tok_token
    content$ = tok_content$
    tok_advance
    ps_variable = ps_variable_p(token, content$)
end function

'Expects: token after variable, variable token as arg
'Results: post token
function ps_variable_p(token, content$)
    debuginfo "Start variable"
    dim sym as symtab_entry_t
    'Do array & udt element stuff here.
    'For now only support simple variables.
  
    'New variable?
    if token = TOK_UNKNOWN then
        sym.identifier = ucase$(content$)
        sym.typ = SYM_VARIABLE
        sym.v1 = ps_default_type
        ps_last_var_index = ps_last_var_index + 1
        sym.v2 = ps_last_var_index
        symtab_add_entry sym
        var = symtab_last_entry
    else
        var = token
    end if

    'Check for type sigil
    sigil = ps_opt_sigil
    if sigil then
        if token <> TOK_UNKNOWN and sigil <> symtab(var).v1 then ps_error "Type suffix does not match existing variable type"
        'Otherwise it's a new variable; set its type
        symtab(var).v1 = sigil
    end if
    ps_variable_p = var
    debuginfo "Completed variable"
end function

'Expects: sigil or otherwise
'Results: post token if sigil present, unchanged otherwise
function ps_opt_sigil
    debuginfo "Start optional sigil"
    if tok_token = TOK_AS then ps_consume TOK_AS
    typ = type_tok2type(tok_token)
    if typ then
        ps_opt_sigil = typ
        tok_advance
    else
        ps_opt_sigil = 0
    end if
    debuginfo "Completed optional sigil"
end function

'Expects: first token of expr
'Results: token after expression
'Note: the expression parser is greedy; it will only stop when it encounters
'      a token that cannot possibly be part of an expression.
function ps_expr
    debuginfo "Start expr"
    ps_expr = pt_expr(0)
    debuginfo "Completed expr"
end function
        
'Expects: statement token
'Results: token after last argument
function ps_stmtreg
    debuginfo "Start stmtreg"
    root = ast_add_node(AST_CALL)
    ast_nodes(root).ref = tok_token

    tok_advance
    ps_funcargs root

    ps_stmtreg = root
    debuginfo "Completed stmtreg"
end function

'Expects: function token
'Results: token after last argument
function ps_funccall
    token = tok_token
    tok_advance
    ps_funccall = ps_funccall_p(token)
end function

'Expects: token after function, function token as arg
'Results: token after last argument
function ps_funccall_p(func)
    debuginfo "Start function call"
    root = ast_add_node(AST_CALL)
    ast_nodes(root).ref = func
    sigil = ps_opt_sigil
    if tok_token = TOK_OPAREN then
        ps_consume TOK_OPAREN
        ps_funcargs root
        ps_consume TOK_CPAREN
    end if
    if sigil > 0 and sigil <> type_of_call(root) then ps_error "Function must have correct type suffix if present"
    ps_funccall_p = root
    debuginfo "Completed function call"
end function

'Expects: first token after function name
'Results: token after argument list
sub ps_funcargs(root)
    debuginfo "Start funcargs"
    'This code first builds a candidate type signature, then tries to match that against an instance signature.
    func = ast_nodes(root).ref
    do
        if ps_is_terminator(tok_token) or tok_token = TOK_CPAREN then exit do
        select case tok_token
        case TOK_COMMA
            ps_consume TOK_COMMA
            ps_funcarg root, candidate$
        case else
            ps_funcarg root, candidate$
        end select
    loop

    'Now we need to find a signature of func that matches candidate$.
    matching_sig = type_find_sig_match(func, candidate$)
    if matching_sig = 0 then ps_error "Cannot find matching type signature"
    ast_nodes(root).ref2 = matching_sig
    'Modify argument nodes to add in casts where needed
    for i = 1 to ast_num_children(root)
        expr = ast_get_child(root, i)
        expr_type = type_of_expr(expr)
        arg_type = type_sig_argtype(matching_sig, i)
        if expr_type <> arg_type then
            ast_replace_child root, i, ast_add_cast(expr, arg_type)
        end if
    next i
    debuginfo "Completed funcargs"
end sub

'Expects: start of expression
'Results: token after expression
sub ps_funcarg(root, candidate$)
    debuginfo "Start funcarg"
    expr = ps_expr
    'Declare whether this expression would satisfy a BYREF argument
    if ast_nodes(expr).typ = AST_VAR then flags = TYPE_BYREF
    candidate$ = type_sig_add_arg$(candidate$, type_of_expr(expr), flags)
    ast_attach root, expr
    debuginfo "Completed funcarg"
end sub

sub ps_error(msg$)
    Error_message$ = msg$
    error 101
end sub

'$include: 'pratt.bm'
'$include: 'tokeng.bm'
