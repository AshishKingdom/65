sub type_dump_functions
    dim sig as type_signature_t
    for i = 1 to htable.elements
        typ = htable_entries(i).typ
        if typ = HE_FUNCTION or typ = HE_INFIX or typ = HE_PREFIX then
            print htable_names(i); " ";
            type_return_sig i, sig
            print type_human_readable$(sig.value); " (";
            while type_next_sig(sig)
                print type_human_readable$(sig.value);
                if sig.succ <> 0 then print ", ";
            wend
            print ")"
        end if
    next i
end sub

sub type_return_sig(token, sig as type_signature_t)
    sig = type_signatures(htable_entries(token).v1)
end sub

function type_next_sig(sig as type_signature_t)
    if sig.succ = 0 then
        type_next_sig = FALSE
        exit function
    end if
    sig = type_signatures(sig.succ)
    type_next_sig = TRUE
end function

function type_add_signature(typ)
    type_last_signature = type_last_signature + 1
    if ubound(type_signatures) = type_last_signature then
        redim _preserve type_signatures(type_last_signature * 2) as type_signature_t
    end if
    type_signatures(type_last_signature).value = typ
    type_add_signature = type_last_signature
end function

sub type_chain_argument(root, typ, required)
    new = type_add_signature(typ)
    type_signatures(new).flags = TYPE_REQUIRED and required
    node = root
    while type_signatures(node).succ <> 0
        node = type_signatures(node).succ
    wend
    type_signatures(node).succ = new
end sub

sub type_restrict_expr(expr, typ)
    select case ast_nodes(expr).typ
    case AST_CALL
        'Don't actually do any restriction, just type check
        if not type_can_cast(type_of_call(expr), typ) then
            fatalerror "Cannot convert return type of function to expected type"
        end if
    case AST_CONSTANT
        'Do something useful?
        if not type_can_cast(type_of_constant(expr), typ) then
            fatalerror "Constant is of unexpected type"
        end if
    case AST_VAR
        type_restrict ast_nodes(expr).ref, typ
    case else
        fatalerror "Cannot restrict type of expression"
    end select
end sub

function type_can_cast(a, b)
    if a = b then
        type_can_cast = TRUE
    elseif a = TYPE_ANY or b = TYPE_ANY then
        type_can_cast = TRUE
    elseif a = TYPE_NUMBER and type_is_numeric(b) then
        type_can_cast = TRUE
    elseif b = TYPE_NUMBER and type_is_numeric(a) then
        type_can_cast = TRUE
    else
        type_can_cast = FALSE
    end if
end function

function type_is_numeric(t)
    'This had to occur somewere, I suppose
    select case t
    case TYPE_INTEGER, TYPE_LONG, TYPE_BIGINTEGER, TYPE_SINGLE, TYPE_DOUBLE, TYPE_OFFSET
        type_is_numeric = TRUE
    case else
        type_is_numeric = FALSE
    end select
end function

sub type_restrict(variable, typ)
    current_type = htable_entries(variable).v1
    print "Restrict "; htable_names(variable); " to "; type_human_readable$(typ)
    if typ = TYPE_ANY then exit sub
    select case current_type
    case TYPE_ANY
        htable_entries(variable).v1 = typ
    case typ
        'Ok. Do nothing.
    case 0
        fatalerror "Attempt to restrict untyped variable"
    case else
        fatalerror "Attemped type restriction conflicts with current restriction"
    end select
end sub

function type_of_expr(root)
    select case ast_nodes(root).typ
    case AST_CONSTANT
        type_of_expr = type_of_constant(root)
    case AST_CALL
        type_of_expr = type_of_call(root)
    case AST_VAR
        type_of_expr = type_of_var(root)
    case else
        fatalerror "Cannot determine type of expression"
    end select
end function

function type_of_constant(node)
    type_of_constant = ast_constant_types(ast_nodes(node).ref)
end function

function type_of_call(node)
    dim sig as type_signature_t
    type_return_sig ast_nodes(node).ref, sig
    type_of_call = sig.value
end function

function type_of_var(node)
    type_of_var = htable_entries(ast_nodes(node).ref).v1
end function

function type_sfx2type(sfx_token)
    select case sfx_token
    case TOK_INTEGER_SFX, TOK_LONG_SFX
        type_sfx2type = TYPE_INTEGER
    case TOK_BIGINTEGER_SFX
        type_sfx2type = TYPE_BIGINTEGER
    case TOK_SINGLE_SFX, TOK_DOUBLE_SFX
        type_sfx2type = TYPE_SINGLE
    case TOK_OFFSET_SFX
        type_sfx2type = TYPE_OFFSET
    case TOK_STRING_SFX
        type_sfx2type = TYPE_STRING
    case else
        type_sfx2type = 0
    end select
end function

function type_human_readable$(typ)
    select case typ
    case TYPE_NONE
        type_human_readable$ = "none"
    case TYPE_ANY
        type_human_readable$ = "any"
    case TYPE_NUMBER
        type_human_readable$ = "number"
    case TYPE_INTEGER, TYPE_LONG
        type_human_readable$ = "integer"
    case TYPE_BIGINTEGER
        type_human_readable$ = "biginteger"
    case TYPE_SINGLE
        type_human_readable$ = "single"
    case TYPE_DOUBLE
        type_human_readable$ = "double"
    case TYPE_STRING
        type_human_readable$ = "string"
    case else
        type_human_readable$ = "unknown"
    end select
end function
