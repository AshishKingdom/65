$CHECKING:OFF
DEFLNG A-Z

SUB htable_add_hentry (ckey$, he AS hentry_t)
    IF htable.elements = UBOUND(htable_entries) THEN
        REDIM _PRESERVE htable_entries(1 to htable.elements * 2) AS hentry_t
        REDIM _PRESERVE htable_names(1 to htable.elements * 2) AS STRING
    END IF
    he.id = htable.elements + 1 '+1 to avoid using 0
    htable_entries(he.id) = he
    htable_names(he.id) = ckey$
    htable_add_local htable, ckey$, he.id
END SUB

FUNCTION htable_get_id (ckey$)
    htable_get_id = htable_get_local(htable, ckey$)
END FUNCTION

FUNCTION htable_last_id
    htable_last_id = htable.elements
END FUNCTION

sub htable_dump
    print " ID          Name     Typ     v1     v2     v3"
    for i = 1 to htable.elements
        print using "###    \            \ ###    ###    ###    ###"; i; htable_names(i); htable_entries(i).typ,htable_entries(i).v1; htable_entries(i).v2; htable_entries(i).v3
    next i
end sub

'Here ends externally callable functions. Those below are for internal use only.

SUB htable_create (ht AS htable_t, expected_elements)
    ht.table = _MEMNEW(HTABLE_ENTRY_SIZE * expected_elements)
    ht.buckets = expected_elements
    _MEMFILL ht.table, ht.table.OFFSET, HTABLE_ENTRY_SIZE * expected_elements, 0 AS LONG
END SUB

SUB htable_expand_if_needed (ht AS htable_t)
    CONST HTABLE_MAX_LOADING = 0.75
    CONST HTABLE_GROWTH_FACTOR = 2
    IF ht.elements / ht.buckets <= HTABLE_MAX_LOADING THEN EXIT FUNCTION
    DIM newht AS htable_t, h~&, klen
    htable_create newht, ht.buckets * HTABLE_GROWTH_FACTOR + 1
    FOR h~& = 0 TO ht.buckets - 1
        klen = _MEMGET(ht.table, ht.table.OFFSET + h~& * HTABLE_ENTRY_SIZE + HTABLE_KEYLEN_OFFSET, LONG)
        IF klen > 0 THEN
            htable_add_memkey newht, _
                              _MEMGET(ht.table, ht.table.offset + h~& * HTABLE_ENTRY_SIZE + HTABLE_KEY_OFFSET, _OFFSET), _
                              klen, _
                              _MEMGET(ht.table, ht.table.OFFSET + h~& * HTABLE_ENTRY_SIZE + HTABLE_DATA_OFFSET, LONG)
        END IF
    NEXT h~&
    _MEMFREE ht.table
    ht = newht
END SUB

SUB htable_add_local (ht AS htable_t, ckey$, value)
    DIM m AS _MEM
    m = _MEMNEW(LEN(ckey$))
    _MEMPUT m, m.OFFSET, ckey$
    htable_add_memkey ht, m.OFFSET, LEN(ckey$), value
    htable_expand_if_needed ht
END SUB

SUB htable_add_memkey (ht AS htable_t, ckey%&, keylen, value)
    DIM h~&, coff%&
    h~& = htable_hash_memkey~&(ckey%&, keylen, ht.buckets)
    DO
        coff%& = _MEMGET(ht.table, ht.table.OFFSET + h~& * HTABLE_ENTRY_SIZE + HTABLE_KEY_OFFSET, _OFFSET)
        IF coff%& = 0 THEN EXIT DO
        h~& = (h~& + 1) MOD ht.buckets
    LOOP
    _MEMPUT ht.table, ht.table.OFFSET + h~& * HTABLE_ENTRY_SIZE + HTABLE_KEY_OFFSET, ckey%&
    _MEMPUT ht.table, ht.table.OFFSET + h~& * HTABLE_ENTRY_SIZE + HTABLE_KEYLEN_OFFSET, keylen AS LONG
    _MEMPUT ht.table, ht.table.OFFSET + h~& * HTABLE_ENTRY_SIZE + HTABLE_DATA_OFFSET, value
    ht.elements = ht.elements + 1
END SUB

FUNCTION htable_get_local (ht AS htable_t, key$)
    DIM h~&, klen, kaddr%&, ckey$
    h~& = htable_hash~&(key$, ht.buckets)
    DO
        klen = _MEMGET(ht.table, ht.table.OFFSET + h~& * HTABLE_ENTRY_SIZE + HTABLE_KEYLEN_OFFSET, LONG)
        IF klen = 0 THEN
            htable_get_local = 0
            EXIT FUNCTION
        END IF
        IF klen = LEN(key$) THEN 'this could be it
            kaddr%& = _MEMGET(ht.table, ht.table.OFFSET + h~& * HTABLE_ENTRY_SIZE + HTABLE_KEY_OFFSET, _OFFSET)
            ckey$ = SPACE$(klen)
            '$CHECKING:OFF
            _MEMGET ht.table, kaddr%&, ckey$ 'ht.table has no meaning here; we are dereferencing kaddr%&
            '$CHECKING:ON
            IF ckey$ = key$ THEN 'got it!
                htable_get_local = _MEMGET(ht.table, ht.table.OFFSET + h~& * HTABLE_ENTRY_SIZE + HTABLE_DATA_OFFSET, LONG)
                EXIT FUNCTION
            END IF
        END IF
        h~& = (h~& + 1) MOD ht.buckets
    LOOP
END FUNCTION

'http://www.cse.yorku.ca/~oz/hash.html
FUNCTION htable_hash~& (s$, mod_size)
    DIM hash~&, i
    hash~& = 5381
    FOR i = 1 TO LEN(s$)
        hash~& = ((hash~& * 33) XOR ASC(s$, i)) MOD mod_size
    NEXT i
    htable_hash~& = hash~&
END FUNCTION

FUNCTION htable_hash_memkey~& (s AS _OFFSET, slen, mod_size)
    DIM hash~&, i, dummy AS _MEM
    hash~& = 5381
    FOR i = 0 TO slen - 1
        '$CHECKING:OFF
        hash~& = ((hash~& * 33) XOR _MEMGET(dummy, s + i, _UNSIGNED _BYTE)) MOD mod_size
        '$CHECKING:ON
    NEXT i
    htable_hash_memkey~& = hash~&
END SUB
$CHECKING:ON
