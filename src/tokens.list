literal newline

# Literals have a hard-coded precedence of 1, which needs to be lower than any other
# prefix <name> <precedence>
 prefix not      2
# infix <name> <precedence> <associativity>
infix and       2   left
infix or        2   left
infix xor       2   left
infix eqv       2   left
infix imp       2   left
infix =(equals) 3   left
infix <(lt)     3   left
infix >(gt)     3   left
infix >=(gt_eq) 3   left
infix <=(lt_eq) 3   left
infix +(plus)   4   left
infix -(minus)  4   left
infix *(star)   5   left
infix /(slash)  5   left
infix ^(pow)    6   left

# Parentheses don't have any real meaning, they only direct the parsing
literal oparen
literal cparen

# Numbers
# numint: 1234, numdec: 12.34, numexp: 12.3E4, numbase: &H1234
literal numint
literal numdec
literal numexp
literal numbase

# A string
literal string

# Some keywords for testing with
# generic vs literal: generics get a htable entry so can be referred to.
# Literals are purely syntactic features.
generic if
literal then
literal else
# end is a little bit of a hack, really. At this stage pretend it's always a
# call to the END function, but in parsing we'll have an exception for gobbling END IF etc.
generic end

generic beep
generic _autodisplay
