deflng a-z
function tok_human_readable$(token)
    tok_human_readable$ = ltrim$(str$(token))
end function

function tok_peek_token(hentry as hentry_t, literal$)
    if tokeng_peeked_token = 0 then 'Need to do a read
        token = tok_next_token(hentry, literal$)
        tokeng_peeked_token = token
        tokeng_peeked_hentry_id = hentry.id
        tokeng_peeked_literal$ = literal$
    end if
    tok_peek_token = tokeng_peeked_token
    if tokeng_peeked_hentry_id > 0 then hentry = htable_entries(tokeng_peeked_hentry_id)
    literal$ = tokeng_peeked_literal$
end function

function tok_next_token(hentry as hentry_t, literal$)
    'ts_mappsings should be static and only initialised once, but this triggers a bug in QB64
    'static ts_mappings(TS_MAX)
    dim ts_mappings(TS_MAX)
    'if not ts_mappings(0) then
        '$include: '../build/ts_mappings.bm'
    'end if
    static in$

    tokeng_peeked_token = 0 'Invalidate any peeked data

    if not tokeng_state.has_data then
        if eof(1) then
            tok_next_token = TOK_EOF
            exit function
        end if
        tokeng_state.index = 1
        line input #1, in$
        tokeng_state.has_data = TRUE
    end if

    ts_content$ = tok_next_ts$(in$ + chr$(10), ts_type)

    select case ts_type
        case 0 'Out of data (an error)
            fatalerror "Unexpected end of line"

        case TS_ID
            id = htable_get_id(ucase$(ts_content$))
            if id = 0 then
                tok_next_token = TOK_GENERIC
            else
                hentry = htable_entries(id)
                tok_next_token = hentry.typ
            end if
            tokeng_state.linestart = FALSE

        case TS_NEWLINE
            tokeng_state.has_data = FALSE
            tokeng_state.linestart = TRUE
            tok_next_token = TOK_NEWLINE

        case else
            tok_next_token = ts_mappings(ts_type)
            tokeng_state.linestart = FALSE
    end select
    ' literal$ is a little badly named; it's just the text that was taken from the input
    literal$ = ucase$(ts_content$)
    print "Read '" + literal$ + "' ("; tok_next_token; ")"
end function

sub tok_init ()
    'read in arrays and set default values for some control variables
    for s = 1 to ubound(t_states~%, 2)
        read t_statenames$(s)
        for b = 1 to 127
            read cmd
            t_states~%(b, s) = cmd
        next b
    next s
    tokeng_state.index = 1
    tokeng_state.curstate = 1
    tokeng_state.has_data = FALSE
    tokeng_state.linestart = TRUE
end sub

function tok_next_ts$(text$, ts_type)
    if tokeng_state.index > len(text$) then
        'Out of data
        ts_type = 0
        exit function
    end if
    for i = tokeng_state.index to len(text$)
        c = asc(text$, i)
        'No utf-8 support for now
        if c > 127 then fatalerror "Character outside character set (" + ltrim$(str$(c)) + ")"
        command = t_states~%(c, tokeng_state.curstate)
        'Rules of the form "A: B ~ Error" encode to 0
        if command = 0 then fatalerror chr$(34) + chr$(c) + chr$(34) + " from " + t_statenames$(tokeng_state.curstate) + " illegal"
        'High byte is next state, low byte is token, high bit of low byte is pushback flag
        ts_type_internal = command and 127
        pushback = command and 128
        'print t_statenames$(tokeng_state.curstate); ":"; c; "~ ";
        tokeng_state.curstate = command \ 2^8
        'print t_statenames$(tokeng_state.curstate)
        if ts_type_internal > 0 then
            ts_type = ts_type_internal
            if pushback then
                'This doesn't include the current character, and uses it next time...
                if ts_type <> 1 then tok_next_ts$ = mid$(text$, tokeng_state.index, i - tokeng_state.index)
                tokeng_state.index = i
            else
                '...but this does include it, and starts from the next character next time.
                if ts_type <> 1 then tok_next_ts$ = mid$(text$, tokeng_state.index, i - tokeng_state.index + 1)
                tokeng_state.index = i + 1
            end if
            if ts_type <> TS_SKIP then exit function
        end if
    next i
    ts_type = 0
end function 

'$include: '../build/ts_data.bm'
