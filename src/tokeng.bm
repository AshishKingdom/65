deflng a-z
function tok_human_readable$(token)
    tok_human_readable$ = ltrim$(str$(token))
end function

sub tok_please_repeat()
    tokeng_state.prefill = TRUE
end sub

function tok_next_token(hentry as hentry_t, literal$)
    if tokeng_state.prefill then
        tokeng_state.prefill = FALSE
        hentry = htable_entries(tokeng_repeat_hentry_id)
        literal$ = tokeng_repeat_literal$
        tok_next_token = tokeng_repeat_token
        exit function
    end if

    'ts_mappsings should be static and only initialised once, but this triggers a bug in QB64
    'static ts_mappings(TS_MAX)
    dim ts_mappings(TS_MAX)
    'if not ts_mappings(0) then
        '$include: '../build/ts_mappings.bm'
    'end if
    static in$

    if not tokeng_state.has_data then
        if eof(1) then
            tok_next_token = TOK_EOF
            exit function
        end if
        tokeng_state.index = 1
        line input #1, in$
        tokeng_state.has_data = TRUE
    end if

    ts_content$ = tok_next_ts$(in$ + chr$(10), ts_type)

    select case ts_type
        case 0 'Out of data (an error)
            fatalerror "Unexpected end of line"

        case TS_ID
            id = htable_get_id(ucase$(ts_content$))
            if id = 0 then
                token = TOK_GENERIC
            else
                hentry = htable_entries(id)
                token = hentry.typ
            end if
            tokeng_state.linestart = FALSE

        case TS_NEWLINE
            tokeng_state.has_data = FALSE
            tokeng_state.linestart = TRUE
            token = TOK_NEWLINE

        case else
            id = htable_get_id(ucase$(ts_content$))
            if id > 0 then
                hentry = htable_entries(id)
                token = hentry.typ
            else
                token = ts_mappings(ts_type)
            end if
            tokeng_state.linestart = FALSE
    end select
    ' literal$ is a little badly named; it's just the text that was taken from the input
    literal$ = ucase$(ts_content$)
    tokeng_repeat_token = token
    tokeng_repeat_hentry_id = id
    tokeng_repeat_literal$ = literal$
    tok_next_token = token
    print "Read '" + literal$ + "' ("; tok_next_token; ")"
end function

sub tok_init ()
    'read in arrays and set default values for some control variables
    for s = 1 to ubound(t_states~%, 2)
        read t_statenames$(s)
        for b = 1 to 127
            read cmd
            t_states~%(b, s) = cmd
        next b
    next s
    tokeng_state.index = 1
    tokeng_state.curstate = 1
    tokeng_state.has_data = FALSE
    tokeng_state.linestart = TRUE
    tokeng_state.prefill = FALSE
end sub

function tok_next_ts$(text$, ts_type)
    if tokeng_state.index > len(text$) then
        'Out of data
        ts_type = 0
        exit function
    end if
    for i = tokeng_state.index to len(text$)
        c = asc(text$, i)
        'No utf-8 support for now
        if c > 127 then fatalerror "Character outside character set (" + ltrim$(str$(c)) + ")"
        command = t_states~%(c, tokeng_state.curstate)
        'Rules of the form "A: B ~ Error" encode to 0
        if command = 0 then fatalerror chr$(34) + chr$(c) + chr$(34) + " from " + t_statenames$(tokeng_state.curstate) + " illegal"
        'High byte is next state, low byte is token, high bit of low byte is pushback flag
        ts_type_internal = command and 127
        pushback = command and 128
        'print t_statenames$(tokeng_state.curstate); ":"; c; "~ ";
        tokeng_state.curstate = command \ 2^8
        'print t_statenames$(tokeng_state.curstate)
        if ts_type_internal > 0 then
            ts_type = ts_type_internal
            if pushback then
                'This doesn't include the current character, and uses it next time...
                if ts_type <> 1 then tok_next_ts$ = mid$(text$, tokeng_state.index, i - tokeng_state.index)
                tokeng_state.index = i
            else
                '...but this does include it, and starts from the next character next time.
                if ts_type <> 1 then tok_next_ts$ = mid$(text$, tokeng_state.index, i - tokeng_state.index + 1)
                tokeng_state.index = i + 1
            end if
            if ts_type <> TS_SKIP then exit function
        end if
    next i
    ts_type = 0
end function 

'$include: '../build/ts_data.bm'
